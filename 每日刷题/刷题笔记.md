# 刷题笔记
## 第一题
**题目介绍**

Write a function that takes in a string of one or more words, and returns the same string, but with all five or more letter words reversed (Just like the name of this Kata). Strings passed in will consist of only letters and spaces. Spaces will be included only when more than one word is present.

Examples:

spinWords( "Hey fellow warriors" ) => returns "Hey wollef sroirraw"

spinWords( "This is a test") => returns "This is a test"

spinWords( "This is another test" )=> returns "This is rehtona test"

人话讲就是 输入一句话（用英文），若句子中有单词的字母个数大于等于5，这个单词就会反转。
```python
# 我的代码
def spin_wrds(sentence):
	a = sentence.split()
	for i in range(len(a)):
		# print(len(a[i]))
		if len(a[i]) > 5:
			a[i] = list(a[i])
			a[i].reverse()
			a[i] = "".join(a[i])
			# print(a[i])
	a = " ".join(a)
	return a
```
```python
# 别人的代码,总有一些变态喜欢这样写代码，原理都差不多,但是不得不承认，真牛逼
def spin_words(sentence):
	return " ".join([x[::-1] if len(x) >= 5 else x for x in sentence.split(" ")])


# 感觉就是抄第一个的
def spin_words(sentence):
    return " ".join(word if len(word)<5 else word[::-1] for word in sentence.split())


def spin_words(sentence):
	words = [word for word in sentence.split()]
	words = [word if len(word) < 5 else word[::-1] for wors in words]
	return " ".join(words)



def spin_words(sentence):
    words = sentence.split()
    output = []
    delimiter = " "
    for word in words:
        if len(word) >= 5:
            output.append(reverse(word))
        else:
            output.append(word)
    return delimiter.join(output)
def reverse(string):
    return string[::-1]



import re
def spin_words(sentence):
    # Your code goes here
    return re.sub(r"\w{5,}", lambda w: w.group(0)[::-1], sentence)

```

## 第二题

**题目介绍**

Usually when you buy something, you're asked whether your credit card number, phone number or answer to your most secret question is still correct. However, since someone could look over your shoulder, you don't want that shown on your screen. Instead, we mask it.

Your task is to write a function `maskify`, which changes all but the last four characters into `'#'`.

```shell
# 例子：
maskify("4556364607935616") == "############5616"
maskify(     "64607935616") ==      "#######5616"
maskify(               "1") ==                "1"
maskify(                "") ==                 ""

# "What was the name of your first pet?"
maskify("Skippy")                                   == "##ippy"
maskify("Nananananananananananananananana Batman!") == "####################################man!"
```

```python
# return masked string
def maskify(cc):

    if len(cc) > 4:
        cc = list(cc)
        for i in range(len(cc) - 4):
            cc[i] = "#"
    return "".join(cc)
```

```shell
Test Results:
masking: 
  matches  
masking: 1
1  matches  1
masking: 22
22  matches  22
masking: 333
333  matches  333
masking: 4444
4444  matches  4444
masking: 3656013700
######3700  matches  ######3700
masking: 3656012840
######2840  matches  ######2840
masking: xxxx3656013004
##########3004  matches  ##########3004
masking: xxxxxx3656013136
############3136  matches  ############3136
masking: 3656013300
######3300  matches  ######3300
masking: xxxxxxxx3656013208
##############3208  matches  ##############3208
masking: xxxxxxxx3656012348
##############2348  matches  ##############2348
masking: 3656012480
######2480  matches  ######2480
masking: xxxx3656012644
##########2644  matches  ##########2644
masking: xx3656012552
########2552  matches  ########2552
masking: xxxxxx3656012716
############2716  matches  ############2716
masking: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3656011824
##################################################1824  matches  ##################################################1824
masking: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3656011988
##############################################################################################1988  matches  ##############################################################################################1988
masking: xxxxxxxxxxxxxxxxxxxxxx3656012152
############################2152  matches  ############################2152
masking: 3656012060
######2060  matches  ######2060
```

```python
# 高人代码
# return masked string
def maskify(cc):
    return "#"*(len(cc)-4) + cc[-4:]

# return masked string
def maskify(cc):
    l = len(cc)
    if l <= 4: return cc
    return (l - 4) * '#' + cc[-4:]

# return masked string
def maskify(cc):
    return '{message:#>{fill}}'.format(message=cc[-4:], fill=len(cc))


# return masked string
def maskify(cc):
    width = len(cc)
    return cc[-4:].rjust(width, '#')
```

**格式化类型**

在占位符内，您可以添加格式化类型以格式化结果：

|      | format()                                                     |
| ---- | ------------------------------------------------------------ |
| `:<` | Left aligns the result (within the available space)                                                        左对齐结果（在可用空间内） |
| `:>` | Right aligns the result (within the available space)  右对齐结果（在可用空间内） |
| `:^` | Center aligns the result (within the available space)  居中对齐结果（在可用空间内） |
| `:=` | Places the sign to the left most position  将标志放置在最左侧 |
| `:+` | Use a plus sign to indicate if the result is positive or negative  使用加号指示结果是正数还是负数 |
| `:-` | Use a minus sign for negative values only  负号仅用于负值    |
| `: ` | Use a space to insert an extra space before positive numbers (and a minus sign befor negative numbers)  使用空格在正数之前插入一个多余的空格（在负数之前使用减号） |
| `:,` | Use a comma as a thousand separator  使用逗号作为千位分隔符  |
| `:_` | Use a underscore as a thousand separator  使用下划线作为千位分隔符 |
| `:b` | Binary format  二进制格式                                    |
| `:c` | Converts the value into the corresponding unicode character   将值转换为相应的unicode字符 |
| `:d` | Decimal format  十进制格式                                   |
| `:e` | Scientific format, with a lower case e  科学格式，小写字母e  |
| `:E` | Scientific format, with an upper case E  科学格式，带有大写字母E |
| `:f` | Fix point number format  定点编号格式                        |
| `:F` | Fix point number format, in uppercase format (show `inf` and `nan` as `INF` and `NAN`)  定点数字格式，以大写形式显示（将“ inf”和“ nan”显示为“ INF”和“ NAN”） |
| `:g` | General format  一般格式                                     |
| `:G` | General format (using a upper case E for scientific notations)  通用格式（使用大写E表示科学计数法） |
| `:o` | Octal format  八进制格式                                     |
| `:x` | Hex format, lower case  十六进制格式，小写                   |
| `:X` | Hex format, upper case  十六进制格式，大写                   |
| `:n` | Number format  数字格式                                      |
| `:%` | Percentage format  百分比格式                                |

## 第三题

**题目描述**

In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.

**Example:**

```python
high_and_low("1 2 3 4 5")  # return "5 1"
high_and_low("1 2 -3 4 5") # return "5 -3"
high_and_low("1 9 3 4 -5") # return "9 -5"
```

```python
def high_and_low(numbers):
    # ...
    numbers = numbers.split()
    
    numbers = [ int(x) for x in numbers ]
    for i in range(len(numbers)):
        if numbers[i] < numbers[0]:
            numbers[i],numbers[0] = numbers[0],numbers[i]
        if numbers[i] > numbers[-1]:
            numbers[i],numbers[-1] = numbers[-1],numbers[i]

    numbers = " ".join([str(i) for i in numbers[-1:]+numbers[:1]])
    
    return numbers
```

```shell
Test Results:
Fixed Tests
Basic Test Cases (8 of 8 Assertions)
Completed in 0.14ms
Random tests
testing for high_and_low("1352 2400 1691 2455 1016 471 1735 225 3021 2600 710 2095 696 2114 3320 1899 334 2715 2292 1018 1655 2256")
testing for high_and_low("392 3376 406 1366 657 1667 3379 2908 1804 2509 944 1705 3378 846 1181 2926 1473 3487 896 2673 1453 1320")
testing for high_and_low("226 2761 1862 1071 1968 1921 -323 62 971 1594 1593 1885 1844 120 2147 2583 2668 37 1636 1260 -278 322")
testing for high_and_low("2591 2030 334 1039 3237 2187 3142 240 191 3043 1186 1684 3151 321 2000 903 396 1454 2145 1166 816 2372")
testing for high_and_low("2307 952 2051 2200 492 307 1558 3346 1406 1933 900 1630 2817 1920 787 371 2630 2882 1330 2205 1501 1340")
testing for high_and_low("1183 1890 3194 2557 1110 2641 1501 346 1799 479 923 2455 2706 197 1795 2068 2534 928 94 2385 1307 361")
testing for high_and_low("2120 814 1845 3306 1737 1939 2777 2396 1679 1555 910 673 273 1236 2668 535 2145 3062 2536 613 1213 2074")
testing for high_and_low("888 2808 2923 1459 2513 18 2674 2739 382 2938 1732 2572 1357 2311 3085 636 682 182 558 1370 2057 986")
testing for high_and_low("103 2678 2581 2131 402 1744 801 2255 2287 1583 1826 3102 95 869 1456 1400 746 20 80 318 876 252")
testing for high_and_low("597 1844 2013 178 2780 2730 1883 2644 1324 2043 -58 13 1951 -251 2543 -237 1295 2099 495 -176 760 2589")
Completed in 3.10ms
```

```python
# 评论区代码
def high_and_low(numbers):
    n = map(int, numbers.split(' '))
    return "{} {}".format(max(n), min(n))


def high_and_low(numbers):
  return " ".join(x(numbers.split(), key=int) for x in (max, min))
```

## 第四题

**题目描述**

A [Narcissistic Number](https://en.wikipedia.org/wiki/Narcissistic_number) is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).

For example, take 153 (3 digits), which is narcisstic:

```
    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
```

and 1652 (4 digits), which isn't:

```
    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
```

The Challenge:

Your code must return **true or false** depending upon whether the given number is a Narcissistic number in base 10.

Error checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function.



```python
def narcissistic(value):
    # Code away
    num = value
    nums = []
    result = 0
    while num > 0:
        i = num % 10
        num //= 10
        nums.append(i)
        
    for i in range(len(nums)):
        result += nums[i]**len(nums) 
    
    return value==result

```

```python
# 高人代码
def narcissistic(value):
    return value == sum(int(x) ** len(str(value)) for x in str(value))


def narcissistic( value ):
    value = str(value)
    size = len(value)
    sum = 0
    for i in value:
        sum += int(i) ** size
    return sum == int(value)


def narcissistic(value):
    return bool(value==sum([int(a) ** len(str(value)) for a in str(value)]))

def narcissistic( value ):
    vstr = str(value)
    nvalue = sum(int(i)**len(vstr) for i in vstr)
    return nvalue == value

def narcissistic( value ):
    digs = map(int, str(value))
    l = len(digs)
    return value == sum(map(lambda x: x**l, digs))
```

## 第五题

**问题描述**

Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for [some of his philosophy that he delivers via Twitter](https://twitter.com/jaden). When writing on Twitter, he is known for almost always capitalizing every word. For simplicity, you'll have to capitalize each word, check out how contractions are expected to be in the example below.

Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

Example:

```
Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"
```



```python
def to_jaden_case(string):
    # ...
    string = string.split()
    return " ".join([string[i].capitalize() for i in range(len(string))])
```



```python
# 他人代码
def toJadenCase(string):        
    return " ".join(w.capitalize() for w in string.split())

def toJadenCase(NonJadenStrings):
    return string.capwords(NonJadenStrings)


```

## 第六题

**问题描述**

Given the triangle of consecutive odd numbers:

```
             1
          3     5
       7     9    11
   13    15    17    19
21    23    25    27    29
...
```

Calculate the row sums of this triangle from the row index (starting at index 1) e.g.:

```python
row_sum_odd_numbers(1); # 1
row_sum_odd_numbers(2); # 3 + 5 = 8
```

```python
# 我的代码
def row_sum_odd_numbers(n):
    #your code here
    return n**3
```

```python
# 评论区代码

def row_sum_odd_numbers(n):
    if type(n)==int and n>0:
        return n**3
    else:
        return "Input a positive integer"
    
def row_sum_odd_numbers(n):
    return sum(range(n*(n-1)+1, n*(n+1), 2))

def row_sum_odd_numbers(n):
    sum = 0
    num = n * n + n - 1
    for i in range(n):
        sum += num
        num -= 2
    return sum
```

## 第七题

**问题描述**

*# Define a function that takes one integer argument and returns logical value true or false depending on if the integer is a prime.*



*# Per Wikipedia, a prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.*



*# Requirements*

*# You can assume you will be given an integer input.*

*# You can not assume that the integer will be only positive. You may be given negative numbers as well (or 0).*

*#* *NOTE* *on performance: There are no fancy optimizations required, but still the most trivial solutions might time out. Numbers go up to 2^31 (or similar, depends on language version). Looping all the way up to n, or n/2, will be too slow.*

```python
# Example*

*# is_prime(1) /\* false \*/*

*# is_prime(2) /\* true \*/*

*# is_prime(-1) /\* false \*/*
```

```python
def is_prime(num):

    res = True
    if num <= 1:
        res = False
    for x in range(2, num):
        if num % x == 0:
            res = False
            break
    return res
# 效率极其低
# 改进
from math import sqrt
def is_prime(num):

    res = True
    if num <= 1:
        return False
    for x in range(2, int(sqrt(num))+1):
        if num % x == 0:
            res = False
            break
    return res
```

```python
# 高人代码
import random

def even_odd(n):
    s, d = 0, n
    while d % 2 == 0:
          s += 1
          d >>= 1
    return s, d

def Miller_Rabin(a, p):
    s, d = even_odd(p-1)
    a = pow(a, d, p)
    if a == 1: return True
    for i in range(s):
        if a == p-1: return True
        a = pow(a, 2, p)
    return False

def is_prime(p):
    if p == 2: return True
    if p <= 1 or p % 2 == 0: return False
    return all(Miller_Rabin(random.randint(2,p-1),p) for _ in range(40))



# -*- coding: utf-8 -*-
def is_prime(num):
    import math

    # There's only one even prime: 2
    if num < 2    : return False
    if num == 2   : return True
    if num %2 == 0: return False

    
    """
    Property:
        Every number n that is not prime has at least one prime divisor p
        such 1 < p < square_root(n)
    """
    root = int(math.sqrt(num))
    
    # We know there's only one even prime, so with that in mind 
    # we're going to iterate only over the odd numbers plus using the above property
    # the performance will be improved
    for i in xrange(3, root+1, 2):
        if num % i == 0: return False
    return True


from math import sqrt
def is_prime(n):
  return n > 1 and all(n % d for d in xrange(2, int(sqrt(n)) + 1))


import gmpy2
def is_prime(num):
  return gmpy2.is_prime(num) if num > 0 else False
```

## 第八题

**题目简介**

The goal of this exercise is to convert a string to a new string where each character in the new string is `"("` if that character appears only once in the original string, or `")"` if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate.

**Examples**

```python
"din"      =>  "((("
"recede"   =>  "()()()"
"Success"  =>  ")())())"
"(( @"     =>  "))((" 
```

```python
def duplicate_encode(word):
    #your code here
    words = list(word.lower())
    result = []
    for i in words:
        if words.count(i) >1:
            result.append(')')
        else:
            result.append('(')
    return "".join(result)
```

```python
# 高人代码
def duplicate_encode(word):
    return "".join(["(" if word.lower().count(c) == 1 else ")" for c in word.lower()])
```

## 第九题

**题目简介**

There is an array with some numbers. All numbers are equal except for one. Try to find it!

```python
find_uniq([ 1, 1, 1, 2, 1, 1 ]) == 2
find_uniq([ 0, 0, 0.55, 0, 0 ]) == 0.55
```

```python
def find_uniq(arr):
    if arr.count(arr[0]) == 1:
        return arr[0]
    for i in arr:
        if arr[0] != i:
            return i

```

```python
# 高人代码
def find_uniq(arr):
    a = sorted(arr)
    return a[0] if a[0] != a[1] else a[-1]

def find_uniq(arr):
    a, b = set(arr)
    return a if arr.count(a) == 1 else b
```



## 第十题

**题目简介**

Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (`HH:MM:SS`)

- `HH` = hours, padded to 2 digits, range: 00 - 99
- `MM` = minutes, padded to 2 digits, range: 00 - 59
- `SS` = seconds, padded to 2 digits, range: 00 - 59

The maximum time never exceeds 359999 (`99:59:59`)

You can find some examples in the test fixtures.

```python
import datetime
def make_readable(seconds):
    # Do something
    SS = seconds % 60
    HH = seconds // 60 // 60
    MM = seconds // 60 % 60
    return '{:0>2d}:{:0>2d}:{:0>2d}'.format(HH,MM,SS)

print(make_readable(0))
print(make_readable(5))
print(make_readable(60))
print(make_readable(86399))
print(make_readable(359999))
```

```python
# 高人代码
def make_readable(s):
    return '{:02}:{:02}:{:02}'.format(s / 3600, s / 60 % 60, s % 60)

def make_readable(seconds):
    hours, seconds = divmod(seconds, 60 ** 2)
    minutes, seconds = divmod(seconds, 60)
    return '{:02}:{:02}:{:02}'.format(hours, minutes, seconds)

def make_readable(seconds):
    return "{0:02d}:{1:02d}:{2:02d}".format(seconds / 3600, seconds / 60 % 60, seconds % 60)

def make_readable(seconds):
    '''Returns the time in `seconds` as a human-readable format (HH:MM:SS).
    '''
    minute, hour = 60, 60 ** 2    
    return "%02d:%02d:%02d" % (
        seconds / hour,
        seconds % hour / minute,
        seconds % hour % minute
    )
```

## 十一题

**题目简介**

Some numbers have funny properties. For example:

> 89 --> 8¹ + 9² = 89 * 1

> 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

> 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p

- we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n.

In other words:

> Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k

If it is the case we will return k, if not return -1.

**Note**: n and p will always be given as strictly positive integers.

```python
dig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
dig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
dig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
dig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
```



```python
def dig_pow(n, p):
    nums = []
    sum = 0
    n1 = n
    while n1 > 0:
        i = n1 % 10
        nums.append(i)
        n1 //= 10
    nums.reverse()
    for i in nums:
        sum += i**p
        p += 1
    k  = sum / n
    return int(k) if sum%n==0 else -1
```

```python
def dig_pow(n, p):
  s = 0
  for i,c in enumerate(str(n)):
     s += pow(int(c),p+i)
  return s/n if s%n==0 else -1

def dig_pow(n, p):
  t = sum( int(d) ** (p+i) for i, d in enumerate(str(n)) )
  return t//n if t%n==0 else -1

def dig_pow(n, p):
    digits = [int(d) for d in str(n)]
    sum = 0
    for i, d in enumerate(digits):
        sum += d ** (p+i)
    if sum % n == 0:
        return sum / n
    else:
        return -1
```

## 十二题

**题目简介**

Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized **only** if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case).

**Examples**

```python
"the-stealth-warrior"` gets converted to `"theStealthWarrior"`
`"The_Stealth_Warrior"` gets converted to `"TheStealthWarrior"
```

```python
import re
def to_camel_case(text):
    #your code here
    items = re.split("_|-",text)
    # print(items)
    for i in range(1,len(items)):
        items[i] = items[i].capitalize()
    return "".join(items)    

t = to_camel_case("the_stealth_warrior")
print(t)
```

```python
def to_camel_case(s):
    return s[0] + s.title().translate(None, "-_")[1:] if s else s



def to_camel_case(text):
    removed = text.replace('-', ' ').replace('_', ' ').split()
    if len(removed) == 0:
        return ''
    return removed[0]+ ''.join([x.capitalize() for x in removed[1:]])


import re
def to_camel_case(text):
    return re.sub('[_-](.)', lambda x: x.group(1).upper(), text)


from re import compile as reCompile

PATTERN = reCompile(r'(?i)[-_]([a-z])')

def to_camel_case(text):
    return PATTERN.sub(lambda m: m.group(1).upper(), text)


def to_camel_case(text):
    return "".join([i if n==0 else i.capitalize() for n,i in enumerate(text.replace("-","_").split("_"))])
```

## 十三题

**题目简介**































